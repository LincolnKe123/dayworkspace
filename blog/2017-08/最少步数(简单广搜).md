# 最少步数
## 闲扯
完成一个简单的广度优先搜索题
##　题目信息
### 描述
这有一个迷宫，有0~8行和0~8列：

    1,1,1,1,1,1,1,1,1
    1,0,0,1,0,0,1,0,1
    1,0,0,1,1,0,0,0,1
    1,0,1,0,1,1,0,1,1
    1,0,0,0,0,1,0,0,1
    1,1,0,1,0,1,0,0,1
    1,1,0,1,0,1,0,0,1
    1,1,0,1,0,0,0,0,1
    1,1,1,1,1,1,1,1,1

* 0表示道路，1表示墙。

现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？

* （注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。）

### 输入

第一行输入一个整数n（0<n<=100），表示有n组测试数据;
随后n行,每行有四个整数a,b,c,d（0<=a,b,c,d<=8）分别表示起点的行、列，终点的行、列。

### 输出

输出最少走几步。

### 样例输入

    2
    3 1  5 7
    3 1  6 7

### 样例输出

    12
    11

### AC代码

    #include <iostream>
    #include <queue>

    using namespace std;
    struct node{
    int x;
    int y;
    int bu;
    };
    int a,b,c,d;
    queue<node> Q;
    int map[9][9]={
    {1,1,1,1,1,1,1,1,1},
    {1,0,0,1,0,0,1,0,1},
    {1,0,0,1,1,0,0,0,1},
    {1,0,1,0,1,1,0,1,1},
    {1,0,0,0,0,1,0,0,1},
    {1,1,0,1,0,1,0,0,1},
    {1,1,0,1,0,1,0,0,1},
    {1,1,0,1,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1}
    };
    int mymap[9][9]={
    {1,1,1,1,1,1,1,1,1},
    {1,0,0,1,0,0,1,0,1},
    {1,0,0,1,1,0,0,0,1},
    {1,0,1,0,1,1,0,1,1},
    {1,0,0,0,0,1,0,0,1},
    {1,1,0,1,0,1,0,0,1},
    {1,1,0,1,0,1,0,0,1},
    {1,1,0,1,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1}
    };
    int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};
    void bfs(int x,int y,int bu)
    {
        struct node tmp1;
        struct node tmp2;
        tmp1.x=x;
        tmp1.y=y;
        tmp1.bu=bu;
        Q.push(tmp1);
        while(!Q.empty())
        {
            tmp1=Q.front();
            map[tmp1.x][tmp1.y]=1;
            Q.pop();
        //cout<<tmp1.x<<" "<<tmp1.y<<" "<<tmp1.bu<<endl;
            //cout<<(tmp1.x==c&&tmp1.y==d)<<endl;
            //cout<<c<<" "<<d<<endl;
            if(tmp1.x==c&&tmp1.y==d)
            {
                cout<<tmp1.bu<<endl;
                return ;
            }

            for(int i=0;i<4;i++)
            {
                tmp2.x=tmp1.x+dir[i][0];
                tmp2.y=tmp1.y+dir[i][1];
                tmp2.bu=tmp1.bu+1;

                if(tmp2.x>0&&tmp2.y>0&&tmp2.x<9&&tmp2.y<9&&map[tmp2.x][tmp2.y]==0)
                Q.push(tmp2);
            }

        }


    }
    int main()
    {
        int n;
        cin>>n;
        while(n--)
        {
            //int a,b,c,d;
            while(!Q.empty())
                Q.pop();
            for(int i=0;i<9;i++)
                for(int j=0;j<9;j++)
                map[i][j]=mymap[i][j];
            cin>>a>>b>>c>>d;
            bfs(a,b,0);

        }
        return 0;
    }

## 作者语

* 这个代码就当自己以后广搜的参考模板了

