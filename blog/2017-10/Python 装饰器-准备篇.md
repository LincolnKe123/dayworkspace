# Python 装饰器-准备篇

上一篇我们了解到了装饰器的一些基础的用法。这篇blog呢就对于装饰器进行进一步的学习。


## 基础了解
如和定义一个不定函数参数个数的函数呢？

用这个 \* 和 \*\* 来实现 为什么要用\*args 和 \*\*kwargs 呢 因为大家都是这样用的当然你可以换成想用的。

    def add(a, b, *args, **kwargs):
        # a, b begin
        print(a)
        print(b)
        # a, b end

        # *args begin
        for tmp in args:
            print(tmp)
        # *args end

        # **kwargs
        for x, y in kwargs.items():
            print("{%s}:{%d}" % (x, y))
        # **kwargs


    add(999, 789, 1, 2, 3, 4, 45, 5, one=1, two=111, hi=1111)

这里发现 和我们想的h是一样的的.

知道这些应该不难写出对一个不定参数个数的函数的装饰器了。其实和上一篇讲的一样。

到现在了我们已经学了不少的关于装饰器的一些东西了。想想我们学了以上的东西可以干什么

1. 我们可以对我们写的代码进行打log,而不用修改原来代码本身
2. 把让自己的代码专注与功能的实现。比如用装饰器进行输入输出数据的检查。
3. 判断当前用户是否有权限运行这个函数。保证安全性
4. 失败重试机制,检测函数的返回值进行重试再也不会出现下面这样的代码

        # 保存100次
        for _ in range(100):
            if file.save() is True:
                break

5. 缓存(不太了解)
6. 单例模式的优雅实现(不了解)
7. 线程装饰器实现简单异步(不了解)

## 闭包

听到这个名字, 他是干嘛的，一脸懵逼是不。 先看一个简单的闭包的例子

    def pass_judgement(pass_line):
        def judge(score):
            if score >= pass_line:
                print("pass")
            else:
                print("failed")
        return judge

    j_100 = pass_judgement(60)
    j_150 = pass_judgement(90)

    j_100(59)
    j_100(61)
    j_150(89)
    j_150(91)

有了这个例子可以去了解一有了这个例子可以去了解一下[**Python LEGB命名空间**](https://copie.cn/index.php/archives/Python%E8%A3%85%E9%A5%B0%E5%99%A8-LEGB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html
)

在上面的例子中 环境变量 pass_line 和 judge() 构成了闭包。在创建闭包的时候，我们通过 pass\_judgement 的参数 pass\_line 来说明这个环境变量的取值，这样我们就知道了具体的及格线90或者60。这样我们就可以提高代码的可复用性。

## 闭包与并行运算(了解)

闭包有效的减少了函数所需定义的参数数目。这 对于并行运算来说有重要的意义。在并行运算的环境下，我们可以让每台电脑负责一个函数，然后将一台电脑的输出和下一台电脑的输入串联起来。最终，我们像流 水线一样工作，从串联的电脑集群一端输入数据，从另一端输出数据。这样的情境最适合只有一个参数输入的函数。闭包就可以实现这一目的。

并行运算正称为一个热点。这也是函数式编程又 热起来的一个重要原因。函数式编程早在1950年代就已经存在，但应用并不广泛。然而，我们上面描述的流水线式的工作并行集群过程，正适合函数式编程。由 于函数式编程这一天然优势，越来越多的语言也开始加入对函数式编程范式的支持。


